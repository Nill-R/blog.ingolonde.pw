+++
author = "Nill Ringil"
categories = ["IT"]
date = 2021-06-20T07:58:41Z
description = ""
draft = false
slug = "ispolzovaniie-incron-dlia-sliezhieniia-za-failami-v-linux"
tags = ["IT"]
title = "Использование incron для слежения за файлами в Linux"

+++


Иногда такое случается, что по вине кого-то имеющего доступ к файлам на сервере или из-за кривых рук администраторов на сервер проникают недобрые люди с нехорошими целями. Безусловно нужно стараться такого не допускать, но еще, ожидая, что пиздец может прийти незаметно, нужно подумать как его сразу заметить.

В ядре Linux начиная с ядра 2.6.13 имеется подсистема inotify позволяющая получать уведомления о событиях связанных с файлами и директориями на файловых системах(начиная с 2.6.32 это Fsnotify, но для нас несущественна смена названия, так как инструменты продолжают использовать для себя имя первоначальной системы)

Благодаря inotify и ПО для работы с ней можно отслеживать изменения в критичных файлах и как-то реагировать на эти события, например срочно слать извещения о том, что с файлами за которыми наблюдаем что-то случилось.

Меня вспомнить об inotify заставила ситуация с заказчиком у которого через зараженную машину одного из сотрудников и используемый для доступа к файлам сайта ftp(именно ftp, а не sftp) были внесены изменения в index.php сайта в результате которых при заходе на сайт с реферарми поисковых систем пользователя усылало куда-то на хутор бабочек ловить, а при прямом заходе сайт продолжал работать.

После того, как мы разобрались что произошло и почему я задумался о том как предотвратить подобное в дальнейшем(помимо отказа от ftp и некоторых административных мер) и решил, что стоит наблюдать за файлами сайта. Сайт использует WordPress в качестве CMS и потому наблюдать нам надо прежде всего за файлами ядра WP(файлы плагинов и тем могут изменяться достаточно часто при всяких обновлениях и будет излишек ложных срабатываний)

Что собственно было сделано

```
apt install incron

```

Установлен incron, аналог cron'а, но не для заданного времени, а для событий на файловой системе и в его задачи добавлено примерно следующее

```
/path/to/wordpress/index.php IN_MODIFY,IN_DELETE_SELF,IN_CLOSE_WRITE /usr/local/bin/modify-file-to-tg.bash $@ $# $%
/path/to/wordpress/wp-config.php IN_MODIFY,IN_DELETE_SELF,IN_CLOSE_WRITE /usr/local/bin/modify-file-to-tg.bash $@ $# $%
/path/to/wordpress/wp-admin/ IN_MODIFY,IN_DELETE_SELF,IN_CLOSE_WRITE /usr/local/bin/modify-file-to-tg.bash $@ $# $%
/path/to/wordpress/wp-includes/ IN_MODIFY,IN_DELETE_SELF,IN_CLOSE_WRITE /usr/local/bin/modify-file-to-tg.bash $@ $# $%

```

Наблюдаем за директориями с ядром WP и за файлами `index.php` и `wp-config.php` в корне. В принципе стоит добавить все файлы корня, но для примера вот так.

В случае модификации, удаления или записи в наблюдаемые файлы или в файлы в наблюдаемых директориях вызывается скрипт, которому incron на вход передает директорию в которой случилось событие, имя файла с которым оно произошло и имя события в текстовом виде. Подробней о том что именно он может передавать можно прочитать в документации на incron.

Я привык для передачи информации с серверов себе использовать telegram-send, который у меня уже настроен на отправку моим ботом мне сообщений, вот его я и буду использовать в скрипте. Вызываемый скрипт выглядит так:

```
#!/usr/bin/env bash

printf "$1$2 $3 on $(date +'%d-%m-%y') at $(date +'%T') on $(hostname)" | telegram-send --stdin --disable-web-page-preview

```

Отправляем сообщение в котором содержится путь к файлу и сам файл, имя произошедшего с ним события, дату и время случившегося. Таким образом если у нас теперь кто-то нехороший что-то сделает с файлом, то я незамедлительно получу об этом сообщение в телеграм и пойду выяснять кто это сделал и зачем.

Аналогично можно вызывать скажем отправку этого дела письмом на твой адрес или посылку в какой-нибудь джаббер, это все на усмотрение того кто делает.

В принципе наблюдение за файлами сайтов это только один из примеров использования inotify и incron, можно придумать еще кучу вариантов, например загнав `/etc` под git делать коммит каждый раз, когда файл был закрыт после записи или выполнение инкрементального бэкапа при обнаружении новых файлов где-то. Описанный мной пример появился просто по следам реальных событий, а потому конечно не является единственно верным и даже методы решения могут кому-то показаться странными.

